# Page Tables

[TOC]

## 对虚拟内存的印象：

1. 一个表将虚拟地址映射到物理地址
2. A：偏移来表示地址
3. 间接地表示物理地址，44为映射到64位地址
4. 每个地址有代理的地址空间，虚拟地址的地位是相同的
5. 允许保护每个进程的地址
6. 是隔离的基础，每个进程都可以假装自己有空间可用
7. 有一种某个形式的映射，可以帮助实现**隔离**

## Address Spaces

### 地址空间

使用虚拟内存可用获得**隔离**

目标：一个程序挂了不会影响操作系统或其他程序

![](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/images/2023/01/20/20230120215916-f1adaa.png)



默认情况：没有隔离，直接在硬件上写

![](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/images/2023/01/20/20230120215932-e2cb10.png)



我们想要某种机制，能够将不同程序之间的内存隔离开来，cat就不会影响到sh。一种实现方式是**地址空间**（Address Spaces）。

![](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/images/2023/01/20/20230120220050-5b510a.png)

现在当我们运行cat后，他的地址空间从0开始，到某个值结束，而sh的地址也从0开始，到某个值结束。

所以cat越界写入时，os会阻止他。

所以现在的问题就是如何在物理内存上创建不同的地址空间



Q&A：

1. 物理内存与虚拟内存大小关系

   没有大小关系，虚拟内存可比物理内存大，反之亦然。page table 使用十分灵活

2. 太多进程使用虚拟内存，物理内存会耗尽吗？

   有可能，如果每个程序都有大的虚拟内存，在某个时间内存就耗尽了。xv6中kalloc返回空余page列表，OS会告知程序是他没有内存了还是整个机器都没有内存了



### 页表

最常见，硬件支持

由处理器的内存管理单元（MMU）

![image-20230120225622953](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/01/20/image-20230120225622953-6a5fed.png)

当应用程序访问地址 `10` 时，OS会将地址`10` 放入内存映射寄存器（SATP）中，CPU告诉内存管理单元到哪里吧虚拟地址转换为物理地址。

> Q&A：
>
> 1. MMU只读取内存并转换，不用保存映射
> 2. stap寄存器的值由内核保护



64位的寄存器会有 $$2^{64}$$ 个内存地址，所以不能对每一个地址分配映射，而是对一个**页面**



## Paging hardware(RISC-V)





## xv6 虚拟内存代码

### 内核地址空间布局

### 用户地址空间布局