## Qiuck Ref

- 1NF
	- 原子性
- 2NF
	- 部分依赖
- 3NF
	- 传递依赖
- BCNF
	- 部分与传递依赖
- 4NF
	- 多值依赖

## 第一范式

需要满足**原子性**

比如说下面这个：

### 不满足的情况

|学生编号|学生姓名|选课列表|
|---|---|---|
|1|小明|语文, 数学, 英语|
|2|小红|数学, 物理|
|3|小李|英语, 历史|

### 修改使满足范式

学生表（Student）：

|学生编号|学生姓名|
|---|---|
|1|小明|
|2|小红|
|3|小李|

选课表（CourseSelection）：

|学生编号|选课名称|
|---|---|
|1|语文|
|1|数学|
|1|英语|
|2|数学|
|2|物理|
|3|英语|
|3|历史|


## 第二范式

![](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/24/20230624215319-b52cdb.png)

将耦合的数据拆开，打散。

**非主键属性完全依赖于候选键（Candidate Key）**



![](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/24/20230624215638-37318d.png)


### 第二范式判断方法
1. 找到所有候选键
2. 找出所有主属性、非主属性
3. 判断非主属性对候选键的依赖


## 第三范式

第二范式的基础上，要求非主键属性不传递依赖于候选键。就是需要消除**传递依赖**。
优点：消除了**CRUD异常**、**数据冗余**、

![](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/24/20230624220119-f69d64.png)


## BCNF

消除主属性对主键的部分与传递依赖

### BCNF 例子

**学生表（Student）：**

|学生编号|学生姓名|课程编号|==课程名称==|教师编号|==教师姓名==|
|---|---|---|---|---|---|
|1|小明|1|数学|1|张老师|
|1|小明|2|英语|2|王老师|
|2|小红|1|数学|1|张老师|
|3|小李|2|英语|3|李老师|

在上述设计中，存在两个候选键：{学生编号, 课程编号}和{学生编号, 教师编号}。而学生表中的非主属性 "课程名称" 只依赖于 "课程编号"，并未依赖于所有的候选键。这违反了BCNF的要求。

为了符合BCNF，我们需要将非主属性 "课程名称" 从学生表中移动到课程表中，并通过关联表建立它们之间的关系。重新设计后的数据库表可能如下所示：

> 简单来说就是 **课程名称** 和 **教师姓名**多余

**学生表（Student）：**

|学生编号|学生姓名|课程编号|教师编号|
|---|---|---|---|
|1|小明|1|1|
|1|小明|2|2|
|2|小红|1|1|
|3|小李|2|3|

**课程表（Course）：**

|课程编号|课程名称|
|---|---|
|1|数学|
|2|英语|

**教师表（Teacher）：**

|教师编号|教师姓名|
|---|---|
|1|张老师|
|2|王老师|
|3|李老师|

## 4NF

消除**多值依赖**，就是要达到一对一的关系。

![](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/24/20230624221244-c44dca.png)
