---
tags:
  - cpl
---
一种常用于解析语法的方法，通常用于解析和处理上下文无关文法（Context-Free Grammar，CFG）。

递归下降解析器通过递归地调用自身来解析给定的输入，并按照语法规则分解它们成为更小的部分，直到达到最基本的语法单元。

这个算法通常用于编程语言解析器和编译器中，用来将源代码转换为抽象语法树（Abstract Syntax Tree，AST）。

## 基本思路

根据文法规则进行自顶向下的分析，每个非终结符号对应一个解析函数，这些函数递归地调用自己来解析符合规则的输入。当输入与文法不匹配时，解析器可能会回溯或者报告语法错误。

## 优缺点
- 优点：**直观**、**简单**，因为它的结构和文法规则很自然地映射到了解析器的代码中。
- 缺点：可能会遇到**左递归**、**回溯**和**性能**问题等挑战，需要针对这些问题进行优化和处理。

## 从《表达式求值》开始

[表达式求值](https://accoding.buaa.edu.cn/problem/303/index)：给你一个数学表达式，请输出表达式的值。

比较常见的算法是使用符号栈和数字栈做运算，但是，当表达式的语法规则愈发复杂（例如引入乘方（\*\*），自定义函数，二进制运算等），解析程序的复杂程度将随之增大，你可能会写出一大堆 `if-else` 然后改代码改到头秃。


在此，让我们用递归下降法重新解决表达式求值

#todo 

## C语言实现
来自维基百科
```c
typedef enum {ident, number, lparen, rparen, times, slash, plus,
    minus, eql, neq, lss, leq, gtr, geq, callsym, beginsym, semicolon,
    endsym, ifsym, whilesym, becomes, thensym, dosym, constsym, comma,
    varsym, procsym, period, oddsym} Symbol;

Symbol sym;
void nextsym(void);
void error(const char msg[]);

int accept(Symbol s) {
    if (sym == s) {
        nextsym();
        return 1;
    }
    return 0;
}

int expect(Symbol s) {
    if (accept(s))
        return 1;
    error("expect: unexpected symbol");
    return 0;
}

void factor(void) {
    if (accept(ident)) {
        ;
    } else if (accept(number)) {
        ;
    } else if (accept(lparen)) {
        expression();
        expect(rparen);
    } else {
        error("factor: syntax error");
        nextsym();
    }
}

void term(void) {
    factor();
    while (sym == times || sym == slash) {
        nextsym();
        factor();
    }
}

void expression(void) {
    if (sym == plus || sym == minus)
        nextsym();
    term();
    while (sym == plus || sym == minus) {
        nextsym();
        term();
    }
}

void condition(void) {
    if (accept(oddsym)) {
        expression();
    } else {
        expression();
        if (sym == eql || sym == neq || sym == lss || sym == leq || sym == gtr || sym == geq) {
            nextsym();
            expression();
        } else {
            error("condition: invalid operator");
            nextsym();
        }
    }
}

void statement(void) {
    if (accept(ident)) {
        expect(becomes);
        expression();
    } else if (accept(callsym)) {
        expect(ident);
    } else if (accept(beginsym)) {
        do {
            statement();
        } while (accept(semicolon));
        expect(endsym);
    } else if (accept(ifsym)) {
        condition();
        expect(thensym);
        statement();
    } else if (accept(whilesym)) {
        condition();
        expect(dosym);
        statement();
    } else {
        error("statement: syntax error");
        nextsym();
    }
}

void block(void) {
    if (accept(constsym)) {
        do {
            expect(ident);
            expect(eql);
            expect(number);
        } while (accept(comma));
        expect(semicolon);
    }
    if (accept(varsym)) {
        do {
            expect(ident);
        } while (accept(comma));
        expect(semicolon);
    }
    while (accept(procsym)) {
        expect(ident);
        expect(semicolon);
        block();
        expect(semicolon);
    }
    statement();
}

void program(void) {
    nextsym();
    block();
    expect(period);
}
```


## Reference

1. [OO-表达式解析之递归下降法 - Dong_HY - 博客园](https://www.cnblogs.com/dhy2000/p/15970225.html)
2. [递归下降解析器 - 维基百科](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E8%A7%A3%E6%9E%90%E5%99%A8)
3. 