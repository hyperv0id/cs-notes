## 地址转换



## 存储保护





## 内存空间扩充

### 覆盖

内存分为固定区和覆盖区，只有模块需要使用的时候才放入覆盖区。

![image-20230630191026506](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/30/image-20230630191026506-aa4d65.png)

问题：程序员必须声明覆盖结构，对用户不透明，增加编程负担。

### 交换

当内存空间紧张时，将部分进程放入外存，部分换回内存。

回忆：低级调度、中级调度、高级调度







### 虚拟存储

TODO



## 内存空间分配回收

**外部碎片**：系统空闲分区太小以至于难以利用

**内部碎片**：给某个进程没有用上全部空间。

### 单一连续

一个系统，只有一个用户进程。

没有外部碎片(系统的碎片)，有内部碎片(用户的碎片)。

<img src="https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/30/image-20230630194540976-0c4a87.png" alt="image-20230630194540976" style="zoom:50%;" />



### 固定分区

<img src="https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/30/image-20230630194737867-be19f2.png" alt="image-20230630194737867" style="zoom:50%;" />

#### 分区大小相等

一开始就将内存划分成一个个固定大小的段

- 缺乏灵活性，适合一个计算机控制多个相同对象的场景。

#### 分区大小不等

系统一开始就把内存划分成不定大小的段，之后不会改变。

- 增加灵活性
- 没有外部碎片。

- 需要建立分区说明表
- 当程序太大时，所有分区都不能满足，只能覆盖。

- 有内部碎片，内存利用率低。

### 动态分区

在运行时改变分区大小。



#### 算法

![image-20230630202640450](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/30/image-20230630202640450-3f58be.png)

##### 首次适应

从低地址找，找到第一个满足的空闲分区。

##### 最佳适应

尽可能多地留下大空间，找刚好满足的。大进程放得下，但是有小空闲区。

##### 最坏适应

每次选最大的，没有空闲小分区，但是大进程放不下。

##### 邻近适应

首次适应导致内存集中在头部，现在改成从上次的位置开始找，而不是表头。