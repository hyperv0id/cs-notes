## WHY

代码的执行顺序可能影响计算结果[^1]。

![Avoiding race conditions in SharedArrayBuffers with Atomics ](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/25/Race_Condition-82b644.png)

> 按照[事件时间](https://lamport.azurewebsites.net/pubs/time-clocks.pdf)理论：
> <del>假设每个线程由量子组成的，根据XXX原理，多个线程在同时执行的时候会穿过彼此。</del>
> <del>有一个穿越的进程杀死了另一个进程的祖父</del>

### 问题建模

如果一段代码可能会修改一些与其他至少一个进程公用的数据，这段代码称为 `critical section`。这时需要防止其它进程进入 `Critical Section`

> 「同步」的核心意义是，规定进程所做的工作之间的**顺序**或者**先序**关系，从而防止一些非法情况的发生。

![Critical Section Problem](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/25/Criticial-Section-Problem-7a41b7.webp)

### 规则

1. `Entry`时申请进入`Critical`，在`Critical`中执行代码，执行完`Exit`
2. 没有两个同时进入`Critical`
3. 系统总体上是在运行的，要么有一个在`Critical`，要么不需要进入`Critical`
4. 进程`Entry`时间有限，不能一直等

### Kernel的解决办法

#### 非抢占式

只有一个进程在Kernel里跑

> Linux 2.X-Giant Lock
>
> 上一把大锁把所有Kernel代码锁起来，因此不会有`Race Condition`

#### 抢占式

#todo

## Peterson 算法

```cpp
int turn;           // 谁被允许 0/1
boolean flag[2];    // 0,1 分别是否准备进入 CS

void foo() {
    while (true) {
        flag[i] = true;     // 我准备好了！我准备好了！
        turn = 1 - i;       // 你准备好了就可以进了
        // 进入条件：1.对方没准备好 2.Turn是自己
        while (flag[1 - i] && turn == 1 - i);   // Wait
        /* critical section */
        flag[i] = false;    // Set ready to false
        /* remainder section */
    }
}
```

> 吹水：现代CPU流水线会把指令重排, Peterson算法就失效了[^3]。需要采用硬件原子指令、内存Barrier等解决办法。
>
> ![img](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/25/2022-11-24-21-41-32-d25428.png)





## Reference

[^1]: [Avoiding race conditions in SharedArrayBuffers with Atomics](https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/)
[^2]: [6 同步及其工具](https://xuan-insr.github.io/核心知识/os/III_process_sync/6_sync_tools/#6-synchronization-tools)
[^3]: https://en.wikipedia.org/wiki/Peterson%27s_algorithm#Note
