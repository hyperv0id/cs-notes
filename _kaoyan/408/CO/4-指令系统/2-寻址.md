## 指令寻址

### 顺序寻址

正常情况：$(PC)+1\rightarrow PC$

问题1：主存按字节编址

![image-20230608160936224](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608160936224-dc5c03.png)





问题2：变长指令字

![image-20230608161141379](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608161141379-e4ff6c.png)

从操作码中获取指令信息，每次加$n$



### 跳跃寻址

转移类指令自己给出



## 数据寻址

用于确定本条指令的地址码指定的真实地址

寻址方式：

```mermaid
mindmap
    root[数据寻址]
        A0[隐含寻址0000]
        A1[立即寻址0001]
        直接寻址0010
        间接寻址0011
        寄存器寻址0100
        寄存器间接寻址0101
        相对寻址0110
        基址寻址0111
        变址寻址1000
        堆栈寻址1001
```

指令内容：

![image-20230608164426748](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608164426748-2e863c.png)



### 直接寻址

> 假设指令字长=机器字长=存储字长，操作数=3

![image-20230608164810935](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608164810935-32632a.png)

LDA指令会将A对应的主存位置上读数据，写入到ACC中，发生两次访存

问题：

1. A的位数有限
2. 操作数地址不易修改

### 间接寻址

![一次间接寻址](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608165006249-cbab10.png)

A保存地址，地址指向EA。三次访存。



两次间接寻址：

A保存地址A1,A1保存A2,A2指向EA。四次访存。

类比：函数的多层调用

<img src="https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608165402523-82eee8.png" alt="image-20230608165402523" style="zoom:50%;" />

### 寄存器寻址

地址码指向某个寄存器

![寄存器寻址指令](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608165536500-9d70e2.png)

<img src="https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608165603830-1b5436.png" alt="寄存器寻址指令示意图" style="zoom:50%;" />

执行访存一次，但价格昂贵



### 寄存器间接寻址

寄存器存指针，仿寄存器后再访存

![image-20230608165805349](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608165805349-7db80f.png)

<img src="https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608165828068-cb9bab.png" alt="image-20230608165828068" style="zoom:67%;" />

### 隐含寻址

一个操作数在主存，另一个在寄存器默认在ACC

![image-20230608165948730](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608165948730-e7d438.png)

### 立即寻址

![image-20230608170249275](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608170249275-d0af41.png)

数据直接就在指令中，但是容量有限



### 偏移寻址-基址寻址
以程序的起始位置为起点

$$
EA = (BR) + A
$$

CPU内部有`BR`寄存器表示程序起始位置，或者采用通用寄存器代替基址寄存器，需要在指令中`R0`指明将那个作为基址寄存器

![image-20230608170815313](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608170815313-a35a89.png)

优点：多道程序并发。



### 偏移寻址-变址寻址

程序员自己决定起点

$$
EA = (IX) + A
$$

![image-20230608171253799](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608171253799-c28b04.png)

几乎和基址寻址相同，但程序员可操作（基址寻址只能有OS控制）

作用：

```cpp
for(int i=0;i<n;i++){
    sum += a[i]; // 将a地址放入IX，OP(sum, ix, i)
}
```



### 偏移寻址-基址+变址

操作系统+用户

用户程序在操作系统中并行时，上面的代码需要加上基址，即$(ACC) + (*a + (IX)) \rightarrow ACC$
$$
EA = (IX) + ((BR)+A)
$$


### 偏移寻址-相对寻址

PC下一条指向地址作为起点（PC每次加一个指令字长）

$$
EA = (PC + ^"1^") + A
$$




![image-20230608172219199](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608172219199-0e14c1.png)

案例：

```cpp
for(int i=0;i<n;i++){
    sum += a[i];
}
```

优点：

1. 代码模块化：相当于转移指令
2. 可移植性：使用相对寻址可以使程序在不同的内存布局和地址分配方案下仍然能够正确地访问数据。程序的源代码中使用的是相对偏移量，而不是具体的物理地址。因此，当程序加载到不同的内存位置时，只需调整基址（起始地址）即可，而无需修改程序的指令或数据。
3. 内存动态分配：相对寻址允许操作系统在运行时动态地分配和释放内存块。OS可以根据需要将不同的程序和数据加载到内存的不同位置，然后通过调整基址来实现相对寻址。这使得内存的使用更加高效和灵活。
4. 安全性：使随机地址，避免恶意攻击



### 堆栈寻址

操作数在堆栈中，使用栈顶指针SP作为操作数地址

![image-20230608173017756](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608173017756-3886a1.png)



硬堆栈：栈保存在寄存器中

软堆栈：栈保存在主存中。

![硬堆栈vs软堆栈](https://pic-1257412153.cos.ap-nanjing.myqcloud.com/images/2023/06/08/image-20230608173151341-15f464.png)
