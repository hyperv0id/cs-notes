> https://leetcode.cn/leetbook/read/top-interview-questions/xmup75/

## 题解

- [x] 看官方题解 (@{2022-11-3 20:30})

```C++
class Solution {
public:
    // unordered_map<pair<int,int>,int> dp;
    unordered_map<int,int> dp;

    int superEggDrop(int k, int n) {
        return calc(k,n);
    }
    // k蛋数，n楼层
    int calc(int k, int n){
        // 只有一个鸡蛋，直接返回
        if(k == 1){return n;}
        // 只有一层楼，返回0，只有两层楼，返回1
        if(n == 0){return 0;}
        
        // 尝试从备忘录里面找
        if(dp.count(pairKN(k,n))){
            return dp[pairKN(k,n)];
        }
        // 没找着
        int l=1, r=n, m;
        int t1,t2; //用于保存算出来的值
        // 二分查找，找到最靠近最值的 l和r
        while(l+1 < r){
            // 为什么条件是 l+1 < r
            // 因为在数学上，我们可以证明出最后的 x0 和 x1 相差 1
            // 最后 l-r 围成的范围只要小于等于 1 就可以跳出循环了

            m = (r+l)/2;
            t1 = calc(k-1, m-1); // 鸡蛋碎了的情况
            t2 = calc(k, n - m); // 鸡蛋没有碎的情况
            if(t1<t2){
                l = m;
            }else if(t1 > t2){
                r = m;
            }
            // 比较特殊的情况，自己就在最值的
            else{l=r=m;}
        }
        int x1 = max(calc(k-1, l-1), calc(k, n-l)); // 第一个解
        int x2 = max(calc(k-1, r-1), calc(k, n-r)); // 第二个解
        dp[pairKN(k,n)] = 1 + min(x1,x2); // 取最小的
        return dp[pairKN(k,n)];
    }

    // 用于在 dp 中定位，相当于 make_pair(k,n);
    int pairKN(int k,int n){
        // 只要保证大于 1e4 就行
        return (k<<20) + n;
    }
};
```